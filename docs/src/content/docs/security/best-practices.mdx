---
title: Security Best Practices
description: Secure deployment and operational security guidelines
---

# Security Best Practices

Guidelines for securely deploying and operating UseCallManager security services.

## Network Security

### Network Isolation

**Recommendation**: Deploy services on an isolated management network.

```
┌──────────────────────────────────────┐
│ Management VLAN (isolated)           │
│  ├─ UseCallManager Services          │
│  ├─ Configuration Service            │
│  └─ Admin Workstations               │
└──────────────────────────────────────┘
         │
         ↓ (Firewall rules)
┌──────────────────────────────────────┐
│ Phone VLAN                           │
│  ├─ Cisco IP Phones                  │
│  └─ TFTP/HTTP Server (read-only)     │
└──────────────────────────────────────┘
```

### Firewall Rules

Restrict access to services:

```bash
# Allow phones to CAPF protocol
iptables -A INPUT -p tcp --dport 3804 -s 10.0.100.0/24 -j ACCEPT

# Block external access to APIs
iptables -A INPUT -p tcp --dport 8081 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 8082 -s 192.168.1.0/24 -j ACCEPT
iptables -A INPUT -p tcp --dport 8081 -j DROP
iptables -A INPUT -p tcp --dport 8082 -j DROP
```

### API Authentication

Currently, APIs have no authentication. **In production**:

**Option 1: API Keys**

```python
from fastapi import Security, HTTPException
from fastapi.security import APIKeyHeader

api_key_header = APIKeyHeader(name="X-API-Key")

async def verify_api_key(api_key: str = Security(api_key_header)):
    if api_key != os.getenv("API_KEY"):
        raise HTTPException(status_code=403, detail="Invalid API key")
    return api_key
```

**Option 2: mTLS (Mutual TLS)**

Configure Caddy for client certificate verification:

```caddyfile
{domain} {
    tls {
        client_auth {
            mode require_and_verify
            trusted_ca_cert_file /etc/caddy/client-ca.pem
        }
    }
    reverse_proxy capf:8082
}
```

**Option 3: OAuth 2.0**

Integrate with corporate OAuth provider (Okta, Auth0, Keycloak).

## Certificate Management

### Issuer Certificate Security

The CAPF issuer certificate is **critical** - it signs all device certificates.

**Protection measures**:
1. **Generate offline** if possible (air-gapped system)
2. **Encrypt private key** at rest
3. **Backup securely** (encrypted, offline storage)
4. **Limit access** to root/admin only
5. **Monitor usage** via audit logs

### Private Key Storage

**Current**: Keys stored in `/var/lib/capf/certificates/`

**Enhanced security**:

```yaml
# Use Docker secrets
secrets:
  issuer_key:
    file: ./secrets/issuer-key.pem

services:
  capf:
    secrets:
      - issuer_key
    environment:
      CAPF_ISSUER_KEY_FILE: /run/secrets/issuer_key
```

**HSM Integration** (future):

```python
# Use PKCS#11 or cloud KMS
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
import pkcs11

# Load from HSM
lib = pkcs11.lib('/usr/lib/softhsm/libsofthsm2.so')
token = lib.get_token(token_label='CAPF')
```

### Certificate Lifecycle

| Phase | Actions | Security Controls |
|-------|---------|-------------------|
| **Generation** | Create issuer cert | Offline system, strong key size |
| **Storage** | Store private key | Encryption, access controls |
| **Usage** | Sign device certs | Audit logging, rate limiting |
| **Rotation** | Renew before expiry | Automated monitoring, dual-cert overlap |
| **Revocation** | Handle compromised certs | CRL/OCSP, ITL updates |

### Key Rotation

Plan for certificate rotation:

```bash
# 1. Generate new issuer certificate
curl -X POST /api/capf/api/v1/issuer-certificate/generate

# 2. Dual-certificate period (both old and new valid)
#    - Keep old cert in ITL for existing phones
#    - New devices get new cert

# 3. After all phones updated, remove old cert from ITL

# 4. Archive old certificate securely
```

## Data Protection

### Database Encryption

**SQLite** (development):

```bash
# Use SQLCipher for encrypted SQLite
pip install sqlcipher3
```

**PostgreSQL** (production):

```sql
-- Enable transparent data encryption
ALTER SYSTEM SET encrypt = 'on';
```

### Backup Security

```bash
# Encrypted backups
tar czf - /var/lib/capf | gpg -e -r admin@example.com > capf-backup.tar.gz.gpg

# Secure off-site storage
rclone copy capf-backup.tar.gz.gpg remote:backups/
```

### Secrets Management

**Never** commit secrets to git:

```bash
# .gitignore
.env
secrets/
*.pem
*.key
*.p12
```

Use environment variables or secret management:

```yaml
# docker-compose.yml
services:
  capf:
    env_file:
      - .env
      - .env.secrets  # Not in git
```

## Monitoring & Auditing

### Logging

Enable comprehensive logging:

```python
# Structured logging
import logging
import json

class JSONFormatter(logging.Formatter):
    def format(self, record):
        return json.dumps({
            'timestamp': record.created,
            'level': record.levelname,
            'message': record.getMessage(),
            'source': record.name,
        })

logging.basicConfig(
    level=logging.INFO,
    handlers=[logging.FileHandler('/var/log/capf/audit.log')]
)
```

### Audit Events

Log critical operations:

```python
# Certificate issuance
logger.info("Certificate issued", extra={
    "device": device_name,
    "key_type": key_type,
    "issued_by": "CAPF",
    "ip_address": request.client.host,
})

# ITL generation
logger.info("ITL file generated", extra={
    "cert_count": len(certificates),
    "signer": signer_cn,
    "requested_by": api_key_id,
})
```

### Monitoring Alerts

Set up alerts for:

- **High error rates** (>5% failed cert requests)
- **Unusual activity** (certificates issued outside business hours)
- **Certificate expiry** (30 days before expiration)
- **Service downtime** (health check failures)
- **Unauthorized access attempts**

Example with Prometheus:

```yaml
groups:
  - name: capf_alerts
    rules:
      - alert: CertificateExpiringSoon
        expr: capf_issuer_cert_expiry_days < 30
        annotations:
          summary: "CAPF issuer certificate expires in {{ $value }} days"
```

## Secure Deployment

### TLS Configuration

**Minimum TLS 1.2** for all HTTPS endpoints:

```caddyfile
{domain} {
    tls {
        protocols tls1.2 tls1.3
        ciphers TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    }
}
```

### Container Security

```yaml
services:
  capf:
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE
    read_only: true
    tmpfs:
      - /tmp
```

### User Permissions

Run as non-root:

```dockerfile
FROM python:3.11-slim
RUN useradd -m -u 1000 capf
USER capf
```

### Dependency Scanning

```bash
# Scan for vulnerabilities
docker scan usecallmanager-capf:latest

# Python dependencies
pip install safety
safety check
```

## Incident Response

### Compromise Response Plan

If issuer certificate is compromised:

1. **Isolate** - Shut down CAPF service
2. **Assess** - Identify affected devices
3. **Revoke** - Generate CRL for compromised certs
4. **Rotate** - Generate new issuer certificate
5. **Remediate** - Update ITL files, re-enroll devices
6. **Review** - Audit logs, improve security controls

### Recovery Procedures

```bash
# 1. Backup current state
docker compose exec -T capf sqlite3 /var/lib/capf/capf.sqlite3 .dump > backup.sql

# 2. Stop services
docker compose down

# 3. Restore from backup
docker compose up -d
docker compose exec -T capf sqlite3 /var/lib/capf/capf.sqlite3 < backup.sql

# 4. Verify integrity
curl https://$DOMAIN/api/capf/api/v1/health
```

## Compliance

### GDPR Considerations

If processing personal data (employee names in certificates):

- Document data retention policies
- Implement data deletion procedures
- Provide data export capabilities
- Maintain processing records

### Audit Requirements

For compliance frameworks (SOC 2, ISO 27001):

- Enable detailed audit logging
- Implement access reviews
- Document security controls
- Conduct regular penetration testing
- Maintain security incident log

## Security Checklist

- [ ] Services deployed on isolated network
- [ ] Firewall rules restrict API access
- [ ] API authentication enabled
- [ ] Issuer private key encrypted at rest
- [ ] Backups encrypted and off-site
- [ ] TLS 1.2+ enforced
- [ ] Containers run as non-root
- [ ] Comprehensive audit logging enabled
- [ ] Monitoring alerts configured
- [ ] Incident response plan documented
- [ ] Certificate rotation scheduled
- [ ] Regular security updates applied
- [ ] Vulnerability scanning automated
- [ ] Access reviews conducted quarterly
